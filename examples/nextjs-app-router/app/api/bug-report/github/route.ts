import { NextRequest } from 'next/server';

export async function POST(request: NextRequest) {
  try {
    const bugData = await request.json();
    
    // Validate required environment variables
    if (!process.env.GITHUB_TOKEN || !process.env.GITHUB_REPO) {
      return Response.json(
        { success: false, error: 'GitHub configuration missing' }, 
        { status: 500 }
      );
    }
    
    // Your GitHub token stays secure on the server
    const response = await fetch(`https://api.github.com/repos/${process.env.GITHUB_REPO}/issues`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.GITHUB_TOKEN}`,
        'Accept': 'application/vnd.github.v3+json',
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        title: bugData.title || 'Bug Report',
        body: formatBugReport(bugData),
        labels: ['bug', 'user-report']
      })
    });
    
    if (!response.ok) {
      throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);
    }
    
    const issue = await response.json();
    
    return Response.json({ 
      success: true, 
      issueId: issue.number.toString(),
      issueUrl: issue.html_url,
      message: `Issue #${issue.number} created successfully`
    });
  } catch (error) {
    console.error('GitHub issue creation failed:', error);
    return Response.json(
      { 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to create GitHub issue' 
      }, 
      { status: 500 }
    );
  }
}

function formatBugReport(data: any): string {
  const sections = [];
  
  // Basic description
  if (data.description) {
    sections.push(`## Description\n${data.description}`);
  }
  
  // Environment details
  sections.push(`## Environment`);
  sections.push(`- **URL:** ${data.url}`);
  sections.push(`- **User Agent:** ${data.userAgent}`);
  sections.push(`- **Viewport:** ${data.viewport.width}x${data.viewport.height}`);
  sections.push(`- **Timestamp:** ${new Date(data.timestamp).toISOString()}`);
  
  if (data.userEmail) {
    sections.push(`- **Email:** ${data.userEmail}`);
  }
  
  // Reproduction steps
  if (data.reproductionSteps && data.reproductionSteps.length > 0) {
    sections.push(`\n## Steps to Reproduce`);
    data.reproductionSteps.forEach((step: string, index: number) => {
      sections.push(`${index + 1}. ${step}`);
    });
  }
  
  // Expected vs Actual behavior
  if (data.expectedBehavior) {
    sections.push(`\n## Expected Behavior\n${data.expectedBehavior}`);
  }
  
  if (data.actualBehavior) {
    sections.push(`\n## Actual Behavior\n${data.actualBehavior}`);
  }
  
  // Console logs (recent errors/warnings)
  if (data.consoleLogs && data.consoleLogs.length > 0) {
    const importantLogs = data.consoleLogs.filter((log: any) => 
      log.level === 'error' || log.level === 'warn'
    );
    
    if (importantLogs.length > 0) {
      sections.push(`\n## Console Errors/Warnings`);
      sections.push('```');
      importantLogs.slice(-5).forEach((log: any) => {
        const time = new Date(log.timestamp).toISOString();
        sections.push(`[${time}] ${log.level.toUpperCase()}: ${log.message}`);
      });
      sections.push('```');
    }
  }
  
  // Network failures
  if (data.networkRequests && data.networkRequests.length > 0) {
    const failedRequests = data.networkRequests.filter((req: any) => 
      req.status === 0 || (req.status && req.status >= 400)
    );
    
    if (failedRequests.length > 0) {
      sections.push(`\n## Failed Network Requests`);
      sections.push('| Method | URL | Status | Duration |');
      sections.push('|--------|-----|--------|----------|');
      failedRequests.slice(-5).forEach((req: any) => {
        sections.push(`| ${req.method} | ${req.url} | ${req.status || 'Failed'} | ${req.duration || 'N/A'}ms |`);
      });
    }
  }
  
  sections.push(`\n---\n*Automatically generated by @zudsniper/bugs*`);
  
  return sections.join('\n');
}