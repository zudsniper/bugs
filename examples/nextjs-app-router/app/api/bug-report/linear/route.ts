import { NextRequest } from 'next/server';

export async function POST(request: NextRequest) {
  try {
    const bugData = await request.json();
    
    // Validate required environment variables
    if (!process.env.LINEAR_API_KEY || !process.env.LINEAR_TEAM_ID) {
      return Response.json(
        { success: false, error: 'Linear configuration missing' }, 
        { status: 500 }
      );
    }
    
    const mutation = `
      mutation IssueCreate($input: IssueCreateInput!) {
        issueCreate(input: $input) {
          success
          issue {
            id
            identifier
            title
            url
          }
        }
      }
    `;
    
    const response = await fetch('https://api.linear.app/graphql', {
      method: 'POST',
      headers: {
        'Authorization': process.env.LINEAR_API_KEY, // Secure on server
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        query: mutation,
        variables: {
          input: {
            title: bugData.title || 'Bug Report',
            description: formatLinearReport(bugData),
            teamId: process.env.LINEAR_TEAM_ID,
            priority: 3, // Medium priority
            ...(process.env.LINEAR_PROJECT_ID && { projectId: process.env.LINEAR_PROJECT_ID }),
          }
        }
      })
    });
    
    if (!response.ok) {
      throw new Error(`Linear API error: ${response.status} ${response.statusText}`);
    }
    
    const result = await response.json();
    
    if (result.errors) {
      throw new Error(`Linear GraphQL error: ${result.errors.map((e: any) => e.message).join(', ')}`);
    }
    
    if (!result.data?.issueCreate?.success) {
      throw new Error('Failed to create Linear issue');
    }
    
    const issue = result.data.issueCreate.issue;
    
    return Response.json({
      success: true,
      issueId: issue.identifier,
      issueUrl: issue.url,
      message: `Linear issue ${issue.identifier} created successfully`
    });
  } catch (error) {
    console.error('Linear issue creation failed:', error);
    return Response.json(
      { 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to create Linear issue' 
      }, 
      { status: 500 }
    );
  }
}

function formatLinearReport(data: any): string {
  const sections = [];
  
  // Basic description
  if (data.description) {
    sections.push(data.description);
    sections.push('');
  }
  
  // Environment details
  sections.push('## Environment');
  sections.push(`**URL:** ${data.url}`);
  sections.push(`**User Agent:** ${data.userAgent}`);
  sections.push(`**Viewport:** ${data.viewport.width}x${data.viewport.height}`);
  sections.push(`**Timestamp:** ${new Date(data.timestamp).toISOString()}`);
  
  if (data.userEmail) {
    sections.push(`**Email:** ${data.userEmail}`);
  }
  
  // Reproduction steps
  if (data.reproductionSteps && data.reproductionSteps.length > 0) {
    sections.push('');
    sections.push('## Steps to Reproduce');
    data.reproductionSteps.forEach((step: string, index: number) => {
      sections.push(`${index + 1}. ${step}`);
    });
  }
  
  // Expected vs Actual behavior
  if (data.expectedBehavior) {
    sections.push('');
    sections.push('## Expected Behavior');
    sections.push(data.expectedBehavior);
  }
  
  if (data.actualBehavior) {
    sections.push('');
    sections.push('## Actual Behavior');
    sections.push(data.actualBehavior);
  }
  
  // Console logs (limited for readability)
  if (data.consoleLogs && data.consoleLogs.length > 0) {
    const errorLogs = data.consoleLogs.filter((log: any) => log.level === 'error');
    
    if (errorLogs.length > 0) {
      sections.push('');
      sections.push('## Console Errors');
      sections.push('```');
      errorLogs.slice(-3).forEach((log: any) => {
        const time = new Date(log.timestamp).toLocaleTimeString();
        sections.push(`[${time}] ${log.level.toUpperCase()}: ${log.message}`);
      });
      sections.push('```');
    }
  }
  
  // Network requests (failed requests only)
  const failedRequests = data.networkRequests?.filter((req: any) => 
    req.status === 0 || (req.status && req.status >= 400)
  ) || [];
  
  if (failedRequests.length > 0) {
    sections.push('');
    sections.push('## Failed Network Requests');
    failedRequests.slice(-3).forEach((req: any) => {
      sections.push(`- **${req.method} ${req.url}** - Status: ${req.status || 'Failed'} (${req.duration || 'N/A'}ms)`);
    });
  }
  
  sections.push('');
  sections.push('---');
  sections.push('*Automatically generated by @zudsniper/bugs*');
  
  return sections.join('\n');
}